先实现一个基本的SM4算法（SM4基本实现.cpp），包含S盒转换，密钥拓展，加密过程的32轮迭代和反序变换。
对SM4算法进行优化：


T-table优化是密码算法中最基础也最有效的优化手段之一，其核心思想是空间换时间：

原理：预计算S盒替换和线性变换L的组合结果，存储在4个256项的表中，每个表对应32位字中的一个字节位置

优势是避免在加密过程中重复执行相同的S盒查找和线性变换计算，将多次操作简化为一次查表操作。

由于T变换是一个32位到32位的变换，可以将其拆分为4个8位输入到32位输出的查表操作。具体做法如下：

1. 将32位输入拆分为4个字节：B0, B1, B2, B3。

2. 对每个字节，预先计算一个表，表的输入是一个字节，输出是经过S盒和部分线性变换后的32位值。注意线性变换L是一个整体，需要将S盒和线性变换L的复合操作分解为4个查表并异或。

但是，线性变换L不能简单地拆分为独立作用于每个字节的操作，因为L是一个32位的线性变换，可以利用线性变换的性质，将其分解为4个查表结果的异或。

定义4个表（每个表256个条目，每个条目32位）：
  
   T0[b] = L((S_box[b] << 24))
   
   T1[b] = L((S_box[b] << 16))
   
   T2[b] = L((S_box[b] << 8))
  
   T3[b] = L((S_box[b]))

但实际上，由于线性变换L是线性的，可以这样考虑：

T(x) = L(S_box(B0)<<24 | S_box(B1)<<16 | S_box(B2)<<8 | S_box(B3))= L(S_box(B0)<<24) ^ L(S_box(B1)<<16) ^ L(S_box(B2)<<8) ^ L(S_box(B3))

因此，可以预先计算：
   
   T0[b] = L( (uint32_t)S_box[b] << 24 )
  
   T1[b] = L( (uint32_t)S_box[b] << 16 )
  
   T2[b] = L( (uint32_t)S_box[b] << 8 )
   
   T3[b] = L( (uint32_t)S_box[b] )

然后，对于32位输入x（拆分为b0, b1, b2, b3），有：T(x) = T0[b0] ^ T1[b1] ^ T2[b2] ^ T3[b3]

这样，就把T变换转换成了4次查表和3次异或。

这是T-table优化后的加密结果：

<img width="740" height="194" alt="image" src="https://github.com/user-attachments/assets/b76d6d46-d965-45f3-aee6-a607df9f3163" />

-----------------------------------------------------------------------------------------------------------------------------


AESNI 指令集优化：

使用 Intel AES-NI 指令集加速加密过程，优化密钥扩展和轮函数计算过程，充分利用硬件加速。
   
   密钥扩展优化：
      
      使用__m128i向量寄存器一次处理4个32位字；
      
      利用_mm_xor_si128等指令并行执行异或操作；
      
      采用向量洗牌指令_mm_shuffle_epi32高效处理密钥轮转；
  
   轮函数计算优化：
     
      使用向量寄存器存储和操作状态数据 (X0-X3)；
    
      通过_mm_insert_epi32和_mm_extract_epi32实现向量与标量的高效转换；
    
      利用_mm_set1_epi32广播子密钥，加速异或操作；
   
   数据转换优化：
     
      使用 AESNI 加载/存储指令 (_mm_loadu_si128, _mm_storeu_si128) 优化内存操作；
     
      利用_byteswap_ulong intrinsic 优化字节序转换；
   

然而效率反而变慢了，而且加密结果也和优化前不一致：

<img width="704" height="214" alt="image" src="https://github.com/user-attachments/assets/8998a09b-19f4-4e23-b035-fc0ac2544e5a" />

能力有限，最后也没有找到合适的解决办法。猜测可能有这些原因：

1.AESNI 指令集是为AES算法量身设计的，而SM4的轮函数结构、密钥扩展方式与AES差异较大。

2.SM4 算法的轮函数存在强数据依赖性：每一轮的输出依赖前一轮的结果（X[i+4]=X[i]^f(X[i+1], X[i+2], X[i+3], rk[i])），这种串行依赖导致向量寄存器（__m128i）的4个32位通道无法真正并行计算，大部分时间可能只用到了向量的1个通道。

3.编译器可能无法完美调度AESNI指令与通用指令，导致CPU流水线停滞。
等等。

至于最新的指令集（GFNI、VPROLD等），即使查找资料添加相关编译选项，编译器最后也还是没能够支持GFNI指令集相关的intrinsic函数：

<img width="704" height="500" alt="屏幕截图 2025-08-12 195737" src="https://github.com/user-attachments/assets/93cb1879-dad7-4aeb-805d-d029458a24fe" />

于是就放弃了。

---------------------------------------------------------------------------------------------------------------

SM4-GCM工作模式：

GCM模式的核心是CTR加密和GMAC认证的结合。CTR模式提供高效加密，而GMAC处理认证。这里需要强调GCM的两个关键优势：并行处理和认证加密一体化。

------------------------------------------------------SM4类分组密码实现------------------------------------------------

  class SM4 {
  private:
      // 常量定义
      static const uint32_t FK[4];  // 系统参数
      static const uint32_t CK[32]; // 固定参数
      uint32_t rk[32];              // 轮密钥存储
      // 核心操作
      static uint32_t rotl(uint32_t x, int n); // 循环左移
      static uint8_t sbox(uint8_t x);          // S盒替换
      static uint32_t byte_sub(uint32_t x);    // 字节替换
      static uint32_t L(uint32_t x);           // 线性变换
      static uint32_t F(uint32_t x0...);       // 轮函数
  public:
      void set_key(const uint8_t key[16]);     // 密钥扩展
      void encrypt_block(const uint8_t in[16], uint8_t out[16]); // 16字节分组加密
  };

算法流程：
  
   1.密钥扩展：
     
      初始密钥与FK异或；
      
      32轮迭代生成轮密钥；
     
      每轮使用S盒和线性变换L；
  
   2.数据加密：
      
      32轮Feistel结构，每轮包含字节替换→线性变换→轮密钥异或；

---------------------------------------------------------GCM类认证加密模式------------------------------------------------

class GCM {
private:
    SM4 sm4;          // SM4 算法实例
    uint8_t H[16];    // 哈希子密钥
    // 核心操作
    void gfmul();           // 伽罗瓦域乘法
    void ghash();           // 认证哈希计算
    void generate_ctr();    // 计数器生成
public:
    void set_key(const uint8_t key[16]); // 初始化密钥
    void encrypt();         // 认证加密
    bool decrypt();         // 认证解密
};

加密流程：
   
   1.初始化：使用全0明文生成哈希子密钥H
  
   2.计数器模式加密：
    
      Nonce-->生成计数器CTR
     
      CTR--> SM4加密--> 密钥流--> 与明文异或
   
   3.认证标签生成：
      
      AAD--> 填充对齐
     
      密文--> 填充对齐
      
      长度信息--> 填充对齐
      
      组合数据--> GHASH计算
     
      GHASH结果--> 与J0异或
     
      异或结果--> 认证标签

解密验证：
   
   1.先解密数据
  
   2.重新计算GHASH
 
   3.对比标签验证完整性和真实性

-----------------------------------------------------测试主函数-------------------------------------------------------

int main() {
    // 1. 初始化测试向量
    uint8_t key[16] = {};
    uint8_t nonce[12] = {};
    uint8_t aad[] = "Additional data";
    // 2. 加密演示
    GCM gcm;
    gcm.set_key(key);
    gcm.encrypt(nonce, plaintext, ...);
    // 3. 正常解密
    bool valid = gcm.decrypt();
    // 4. 篡改检测测试
    ciphertext[0] ^= 0x01; // 修改密文
    valid = gcm.decrypt(); // 应返回false
}

测试流程：
  
   1.使用标准测试向量初始化
  
   2.执行加密并输出：密钥/Nonce/AAD/明文/生成的密文和认证标签
  
   3.验证正常解密
  
   4.篡改密文后验证标签检测

-------------------------------------------------------------------------------------------------

运行结果：

<img width="708" height="229" alt="屏幕截图 2025-08-13 015933" src="https://github.com/user-attachments/assets/1a27c781-a43a-48ba-a865-26b8a45cc2b0" />


使用T-table方法优化后，运行结果：

<img width="658" height="232" alt="image" src="https://github.com/user-attachments/assets/02295a86-d6ee-48a2-8ed8-08cd345447fb" />

提升效率并不明显。







