先实现一个基本的SM4算法（SM4基本实现.cpp），包含S盒转换，密钥拓展，加密过程的32轮迭代和反序变换。
对SM4算法进行优化：

T-table优化是密码算法中最基础也最有效的优化手段之一，其核心思想是空间换时间：
原理：预计算S盒替换和线性变换L的组合结果，存储在4个256项的表中，每个表对应32位字中的一个字节位置
优势是避免在加密过程中重复执行相同的S盒查找和线性变换计算，将多次操作简化为一次查表操作。
由于T变换是一个32位到32位的变换，可以将其拆分为4个8位输入到32位输出的查表操作。具体做法如下：
1. 将32位输入拆分为4个字节：B0, B1, B2, B3。
2. 对每个字节，预先计算一个表，表的输入是一个字节，输出是经过S盒和部分线性变换后的32位值。注意线性变换L是一个整体，需要将S盒和线性变换L的复合操作分解为4个查表并异或。
但是，线性变换L不能简单地拆分为独立作用于每个字节的操作，因为L是一个32位的线性变换，可以利用线性变换的性质，将其分解为4个查表结果的异或。
定义4个表（每个表256个条目，每个条目32位）：
   T0[b] = L((S_box[b] << 24))
   T1[b] = L((S_box[b] << 16))
   T2[b] = L((S_box[b] << 8))
   T3[b] = L((S_box[b]))
但实际上，由于线性变换L是线性的，可以这样考虑：
T(x) = L(S_box(B0)<<24 | S_box(B1)<<16 | S_box(B2)<<8 | S_box(B3))= L(S_box(B0)<<24) ^ L(S_box(B1)<<16) ^ L(S_box(B2)<<8) ^ L(S_box(B3))
因此，可以预先计算：
   T0[b] = L( (uint32_t)S_box[b] << 24 )
   T1[b] = L( (uint32_t)S_box[b] << 16 )
   T2[b] = L( (uint32_t)S_box[b] << 8 )
   T3[b] = L( (uint32_t)S_box[b] )
然后，对于32位输入x（拆分为b0, b1, b2, b3），有：T(x) = T0[b0] ^ T1[b1] ^ T2[b2] ^ T3[b3]
这样，就把T变换转换成了4次查表和3次异或。


AESNI 指令集优化：
使用 Intel AES-NI 指令集加速加密过程
通过__m128i数据类型和相关 intrinsics 函数利用 128 位 SIMD 操作
优化密钥扩展和轮函数计算过程，充分利用硬件加速
