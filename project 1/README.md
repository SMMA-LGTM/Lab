先实现一个基本的SM4算法（SM4基本实现.cpp），包含S盒转换，密钥拓展，加密过程的32轮迭代和反序变换。
对SM4算法进行优化：

T-table优化是密码算法中最基础也最有效的优化手段之一，其核心思想是空间换时间：
原理：预计算S盒替换和线性变换L的组合结果，存储在4个256项的表中，每个表对应32位字中的一个字节位置
优势是避免在加密过程中重复执行相同的S盒查找和线性变换计算，将多次操作简化为一次查表操作。
由于T变换是一个32位到32位的变换，可以将其拆分为4个8位输入到32位输出的查表操作。具体做法如下：
1. 将32位输入拆分为4个字节：B0, B1, B2, B3。
2. 对每个字节，预先计算一个表，表的输入是一个字节，输出是经过S盒和部分线性变换后的32位值。注意线性变换L是一个整体，需要将S盒和线性变换L的复合操作分解为4个查表并异或。
但是，线性变换L不能简单地拆分为独立作用于每个字节的操作，因为L是一个32位的线性变换，可以利用线性变换的性质，将其分解为4个查表结果的异或。
定义4个表（每个表256个条目，每个条目32位）：
   T0[b] = L((S_box[b] << 24))
   T1[b] = L((S_box[b] << 16))
   T2[b] = L((S_box[b] << 8))
   T3[b] = L((S_box[b]))
但实际上，由于线性变换L是线性的，可以这样考虑：
T(x) = L(S_box(B0)<<24 | S_box(B1)<<16 | S_box(B2)<<8 | S_box(B3))= L(S_box(B0)<<24) ^ L(S_box(B1)<<16) ^ L(S_box(B2)<<8) ^ L(S_box(B3))
因此，可以预先计算：
   T0[b] = L( (uint32_t)S_box[b] << 24 )
   T1[b] = L( (uint32_t)S_box[b] << 16 )
   T2[b] = L( (uint32_t)S_box[b] << 8 )
   T3[b] = L( (uint32_t)S_box[b] )
然后，对于32位输入x（拆分为b0, b1, b2, b3），有：T(x) = T0[b0] ^ T1[b1] ^ T2[b2] ^ T3[b3]
这样，就把T变换转换成了4次查表和3次异或。
这是T-table优化后的加密结果：
<img width="740" height="194" alt="image" src="https://github.com/user-attachments/assets/b76d6d46-d965-45f3-aee6-a607df9f3163" />


AESNI 指令集优化：
使用 Intel AES-NI 指令集加速加密过程，优化密钥扩展和轮函数计算过程，充分利用硬件加速。
   密钥扩展优化：
      使用__m128i向量寄存器一次处理4个32位字；
      利用_mm_xor_si128等指令并行执行异或操作；
      采用向量洗牌指令_mm_shuffle_epi32高效处理密钥轮转；
   轮函数计算优化：
      使用向量寄存器存储和操作状态数据 (X0-X3)；
      通过_mm_insert_epi32和_mm_extract_epi32实现向量与标量的高效转换；
      利用_mm_set1_epi32广播子密钥，加速异或操作；
   数据转换优化：
      使用 AESNI 加载/存储指令 (_mm_loadu_si128, _mm_storeu_si128) 优化内存操作；
      利用_byteswap_ulong intrinsic 优化字节序转换；
   
然而效率反而变慢了，而且加密结果也和优化前不一致：
<img width="704" height="214" alt="image" src="https://github.com/user-attachments/assets/8998a09b-19f4-4e23-b035-fc0ac2544e5a" />

能力有限，最后也没有找到合适的解决办法。猜测可能有这些原因：
1.AESNI 指令集是为AES算法量身设计的，而SM4的轮函数结构、密钥扩展方式与AES差异较大。
2.SM4 算法的轮函数存在强数据依赖性：每一轮的输出依赖前一轮的结果（X[i+4]=X[i]^f(X[i+1], X[i+2], X[i+3], rk[i])），这种串行依赖导致向量寄存器（__m128i）的4个32位通道无法真正并行计算，大部分时间可能只用到了向量的1个通道。
3.编译器可能无法完美调度AESNI指令与通用指令，导致CPU流水线停滞。
等等。

至于最新的指令集（GFNI、VPROLD等），即使查找资料添加相关编译选项，编译器最后也还是没能够支持GFNI指令集相关的intrinsic函数：
<img width="975" height="669" alt="屏幕截图 2025-08-12 195737" src="https://github.com/user-attachments/assets/93cb1879-dad7-4aeb-805d-d029458a24fe" />
于是就放弃了。
