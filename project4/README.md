# Project 4: SM3的软件实现与优化
a）：与Project 1类似，从SM3的基本软件实现出发，参考付勇老师的PPT，不断对SM3的软件执行效率进行改进
b）：基于sm3的实现，验证length-extension attack
c）：基于sm3的实现，根据RFC6962构建Merkle树（10w叶子节点），并构建叶子的存在性证明和不存在性证明
#
实现一个基本的SM3算法。
```
SM3是中国国家密码管理局于2010年发布的密码哈希算法标准。
输出长度：256位(32字节)
分组长度：512位(64字节)
消息长度限制：最大2^64-1位
设计结构：Merkle-Damgård结构
计算步骤：填充→消息扩展→压缩函数迭代
```
**在SM3.cpp中**，定义了 SM3 所需的所有置换函数 (P0, P1)、布尔函数 (FF, GG) 和常量 (Tj)。实现消息扩展函数和压缩函数，包含完整的填充过程，处理消息长度不是 512 位倍数的情况

类接口设计：
    
    提供reset()方法重置哈希状态；update()方法支持分块处理大数据；final()方法完成哈希计算并获取结果；静态方法hash()提供一次性计算接口

辅助功能：

    bytes_to_hex()函数将哈希结果转换为十六进制字符串；包含测试案例空字符串和短字符串，验证实现的正确性；演示如何分块处理长数据

## SM3软件实现与优化
SM3 优化实现需结合算法特性与硬件架构（X86-64、ARM64 等），核心围绕消息扩展优化“压缩过程优化”“硬件指令利用” 和 “寄存器 / 内存管理” 展开。
## X86_64 架构优化
### SIMD 指令集使用：

```
1.AVX2/SSE4.1指令进行消息扩展，一次处理128位数据
2.vpshufb进行字节序转换，vpxor进行并行异或运算
3._rotl intrinsic函数利用硬件循环移位指令
```

### 循环优化：

```
1.拆分64轮迭代为0-15和16-63两段，消除条件判断
2.对字节转十六进制等辅助函数进行循环展开
```

### 内存访问优化：

```
1.对64字节对齐的数据块进行直接处理，减少中间缓冲区复制
2.使用SIMD指令批量加载或存储数据，提高内存带宽利用率
```

### 寄存器利用：

```
1.register关键字提示编译器优先分配寄存器
2.减少不必要的内存读写操作，保持关键数据在寄存器中
```

## ARM64 架构优化
### NEON 指令集利用：

```
1.使用32 位NEON寄存器进行消息扩展和压缩
2.利用vrev32q_u32指令高效处理字节序转换
3.使用veorq_u32进行并行异或运算
```

### 架构特性利用：

```
1.利用ARM64的32个通用寄存器优势，减少内存访问
2.使用桶形移位器特性，在单条指令中完成移位和逻辑运算
3.利用条件选择指令减少分支跳转
```

### 缓存优化：

```
1.按缓存大小优化数据块处理粒度，16个块为一组
2.减少跨缓存行访问，提高数据局部性
```

### 提高指令效率：

```
1.使用movz+movk组合高效加载64位立即数
2.利用LEA-like操作组合加法和移位，减少指令数量
```
**代码详见SM3-optimized.h**
